19.3 Variance annotations 

  Queue是一个trait，不能作为参数类型，而Queue[String] 是一个类型，Queue也是一个type constructor，因为通过添加参数值可构建一个type
Quene也是一个generic trait，即可以定义很多具体类型如：Queue[Int] ，Queue[String] 等....
Quene的的参数类型拥有不变的-- nonvariant 子类，即quene的不同元素类型之间不存在子类关系：Queue[String] 不能被用作Queue[AnyRef],但是你可以通过在了类型前端增加+符号来使其能拥有子类：
  trait Queue[+T] { ... }//指明在参数中，类型T的子类是一个协变类型-- nonvariant ，那么以上Queue[String] 就是Queue[AnyRef]的子类了；与协变类型相对的是
  逆变-  (contravariant ) ，形如：trait Queue[-T] { ... } //如果T是S的子类，那么Queue[S]是Queue[T]的子类
  所以 因为类型参数是不变的，还是协变，逆变 就叫做parameter’s variance，而在类型参数前的符号=- 就叫做 variance annotations--型变注释
Variance and arrays
在java的数组中允许协变类型 但是一下：
// this is Java
String[] a1 = { "abc" };
Object[] a2 = a1;
a2[0] = new Integer(17);
String s = a1[0];
编译通过，在执行中会出现Exception in thread "main" java.lang.ArrayStoreException: 异常。而在Scala中数组的类型之间是不能直接协变的。
scala> val a1 = Array("abc")  
a1: Array[java.lang.String] = Array(abc)
scala> val a2: Array[Any] = a1
<console>:5: error: type mismatch;
found : Array[java.lang.String]
required: Array[Any]
val a2: Array[Any] = a1
但是Scala也提供了方案执行类似于java的操作：
scala> val a2: Array[Object] = a1.asInstanceOf[Array[Object] ]
a2: Array[java.lang.Object] = Array(abc) 
但是同样可能遇到类似ArrayStore的异常

19.4 Checking variance annotations
所有违反类型健全包括可赋值的域或数组元素都是不被接受的，包括参数类型
后面部分略....

19.5 Lower bounds
class Queue[+T] (private val leading: List[T] , private val trailing: List[T] ) {
  def enqueue[U >: T](x: U) = new Queue[U] (leading, x :: trailing) // ...
}

U是T的子类，定义T作为U的下限，现在对于enqueue的参数是U，而返回值类型是Queue[U] ；例如 class Fruit有两个子类：Apple 和 Orange，
如果给 Queue[Apple]  添加一个Queue[Orange]，那么结果将得到 Queue[Fruit]，如果T是一个更加具体的类型 Apple，其结果还是一样，因为
U仍然是T(Apple)的一个超类
 variance annotations和 lower bounds在一起良好的协作，是type-driven design的一个很好地例子，接口类型指导了明细的实现和设计
 这个观测也是scala喜欢declarationsite variance而不是use-site variance 
 
 
 19.6 Contravariance
  trait OutputChannel[-T] {
    def write(x: T)
  }
以上例子中定义了逆变类型T，所以OutputChannel[AnyRefs] 是OutputChannel[String] ，的子类，唯一操作就是将Stirng类型参数传给他，但是
OutputChannel[AnyRefs]也能做同样的事，所以用OutputChannel[AnyRefs] 可以替代OutputChannel[String] ，但是相比之下这种替换并不安全，
因为替换后的OutputChannel[AnyRefs]，我们可以传递任何对象给他，而如果传递费String类型的[OutputChannel]在运行时则会产生异常
  covariance and contravariance 混合使用：
  trait Function1[-S, +T] {
    def apply(x: S): T
  }
  他满足里氏替换原则
  
  另外一个例子：
  class Publication(val title: String)
class Book(title: String) extends Publication(title)
object Library {
val books: Set[Book] =
  Set(
  new Book("Programming in Scala"),
  new Book("Walden")
  )
  def printBookList(info: Book => AnyRef) {
    for (book <- books) println(info(book))//函数info 需要的参数类型是Book,Book指的是传递给函数的参数类型是Book
  }
}
object Customer extends Application {
  def getTitle(p: Publication): String = p.title
  Library.printBookList(getTitle) // 传递函数getTitle 给printBookList 方法，但printBookList需要的参数是Book，
  //而传递的函数的参数为Publication，Book是Publication的子类，所以这里是一个逆变，将超类作为子类传递给函数，这里可能有安全转换的问题
  //但是这里函数直接是定义在外部，其实现直接依赖于外部实现的参数类型，而外部类型是一个超类。根据里氏替换原则，超类需要的地方，那么子类也一定可以存在
  //所以Book 能被替换为Pulication
  
}

